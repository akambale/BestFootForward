module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBlurb {
  count: Int!
}

type AggregateFeedback {
  count: Int!
}

type AggregatePic {
  count: Int!
}

type AggregateRating {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Blurb {
  id: ID!
  owner: User!
  text: String!
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating!]
}

type BlurbConnection {
  pageInfo: PageInfo!
  edges: [BlurbEdge]!
  aggregate: AggregateBlurb!
}

input BlurbCreateInput {
  id: ID
  owner: UserCreateOneWithoutBlurbsInput!
  text: String!
  ratings: RatingCreateManyWithoutBlurbInput
}

input BlurbCreateManyWithoutOwnerInput {
  create: [BlurbCreateWithoutOwnerInput!]
  connect: [BlurbWhereUniqueInput!]
}

input BlurbCreateOneWithoutRatingsInput {
  create: BlurbCreateWithoutRatingsInput
  connect: BlurbWhereUniqueInput
}

input BlurbCreateWithoutOwnerInput {
  id: ID
  text: String!
  ratings: RatingCreateManyWithoutBlurbInput
}

input BlurbCreateWithoutRatingsInput {
  id: ID
  owner: UserCreateOneWithoutBlurbsInput!
  text: String!
}

type BlurbEdge {
  node: Blurb!
  cursor: String!
}

enum BlurbOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type BlurbPreviousValues {
  id: ID!
  text: String!
}

input BlurbScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [BlurbScalarWhereInput!]
  OR: [BlurbScalarWhereInput!]
  NOT: [BlurbScalarWhereInput!]
}

type BlurbSubscriptionPayload {
  mutation: MutationType!
  node: Blurb
  updatedFields: [String!]
  previousValues: BlurbPreviousValues
}

input BlurbSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BlurbWhereInput
  AND: [BlurbSubscriptionWhereInput!]
  OR: [BlurbSubscriptionWhereInput!]
  NOT: [BlurbSubscriptionWhereInput!]
}

input BlurbUpdateInput {
  owner: UserUpdateOneRequiredWithoutBlurbsInput
  text: String
  ratings: RatingUpdateManyWithoutBlurbInput
}

input BlurbUpdateManyDataInput {
  text: String
}

input BlurbUpdateManyMutationInput {
  text: String
}

input BlurbUpdateManyWithoutOwnerInput {
  create: [BlurbCreateWithoutOwnerInput!]
  delete: [BlurbWhereUniqueInput!]
  connect: [BlurbWhereUniqueInput!]
  set: [BlurbWhereUniqueInput!]
  disconnect: [BlurbWhereUniqueInput!]
  update: [BlurbUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [BlurbUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [BlurbScalarWhereInput!]
  updateMany: [BlurbUpdateManyWithWhereNestedInput!]
}

input BlurbUpdateManyWithWhereNestedInput {
  where: BlurbScalarWhereInput!
  data: BlurbUpdateManyDataInput!
}

input BlurbUpdateOneWithoutRatingsInput {
  create: BlurbCreateWithoutRatingsInput
  update: BlurbUpdateWithoutRatingsDataInput
  upsert: BlurbUpsertWithoutRatingsInput
  delete: Boolean
  disconnect: Boolean
  connect: BlurbWhereUniqueInput
}

input BlurbUpdateWithoutOwnerDataInput {
  text: String
  ratings: RatingUpdateManyWithoutBlurbInput
}

input BlurbUpdateWithoutRatingsDataInput {
  owner: UserUpdateOneRequiredWithoutBlurbsInput
  text: String
}

input BlurbUpdateWithWhereUniqueWithoutOwnerInput {
  where: BlurbWhereUniqueInput!
  data: BlurbUpdateWithoutOwnerDataInput!
}

input BlurbUpsertWithoutRatingsInput {
  update: BlurbUpdateWithoutRatingsDataInput!
  create: BlurbCreateWithoutRatingsInput!
}

input BlurbUpsertWithWhereUniqueWithoutOwnerInput {
  where: BlurbWhereUniqueInput!
  update: BlurbUpdateWithoutOwnerDataInput!
  create: BlurbCreateWithoutOwnerInput!
}

input BlurbWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  ratings_every: RatingWhereInput
  ratings_some: RatingWhereInput
  ratings_none: RatingWhereInput
  AND: [BlurbWhereInput!]
  OR: [BlurbWhereInput!]
  NOT: [BlurbWhereInput!]
}

input BlurbWhereUniqueInput {
  id: ID
}

scalar DateTime

type Feedback {
  id: ID!
  text: String!
  createdAt: DateTime!
  flagged: Boolean!
  flaggedBy: User
  feedbackReceiver: User!
  feedbackGiver: User!
}

type FeedbackConnection {
  pageInfo: PageInfo!
  edges: [FeedbackEdge]!
  aggregate: AggregateFeedback!
}

input FeedbackCreateInput {
  id: ID
  text: String!
  flagged: Boolean!
  flaggedBy: UserCreateOneWithoutFeedbackFlaggedInput
  feedbackReceiver: UserCreateOneWithoutFeedbackReceivedInput!
  feedbackGiver: UserCreateOneWithoutFeedbackGivenInput!
}

input FeedbackCreateManyWithoutFeedbackGiverInput {
  create: [FeedbackCreateWithoutFeedbackGiverInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateManyWithoutFeedbackReceiverInput {
  create: [FeedbackCreateWithoutFeedbackReceiverInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateManyWithoutFlaggedByInput {
  create: [FeedbackCreateWithoutFlaggedByInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateWithoutFeedbackGiverInput {
  id: ID
  text: String!
  flagged: Boolean!
  flaggedBy: UserCreateOneWithoutFeedbackFlaggedInput
  feedbackReceiver: UserCreateOneWithoutFeedbackReceivedInput!
}

input FeedbackCreateWithoutFeedbackReceiverInput {
  id: ID
  text: String!
  flagged: Boolean!
  flaggedBy: UserCreateOneWithoutFeedbackFlaggedInput
  feedbackGiver: UserCreateOneWithoutFeedbackGivenInput!
}

input FeedbackCreateWithoutFlaggedByInput {
  id: ID
  text: String!
  flagged: Boolean!
  feedbackReceiver: UserCreateOneWithoutFeedbackReceivedInput!
  feedbackGiver: UserCreateOneWithoutFeedbackGivenInput!
}

type FeedbackEdge {
  node: Feedback!
  cursor: String!
}

enum FeedbackOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  flagged_ASC
  flagged_DESC
}

type FeedbackPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  flagged: Boolean!
}

input FeedbackScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  flagged: Boolean
  flagged_not: Boolean
  AND: [FeedbackScalarWhereInput!]
  OR: [FeedbackScalarWhereInput!]
  NOT: [FeedbackScalarWhereInput!]
}

type FeedbackSubscriptionPayload {
  mutation: MutationType!
  node: Feedback
  updatedFields: [String!]
  previousValues: FeedbackPreviousValues
}

input FeedbackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackWhereInput
  AND: [FeedbackSubscriptionWhereInput!]
  OR: [FeedbackSubscriptionWhereInput!]
  NOT: [FeedbackSubscriptionWhereInput!]
}

input FeedbackUpdateInput {
  text: String
  flagged: Boolean
  flaggedBy: UserUpdateOneWithoutFeedbackFlaggedInput
  feedbackReceiver: UserUpdateOneRequiredWithoutFeedbackReceivedInput
  feedbackGiver: UserUpdateOneRequiredWithoutFeedbackGivenInput
}

input FeedbackUpdateManyDataInput {
  text: String
  flagged: Boolean
}

input FeedbackUpdateManyMutationInput {
  text: String
  flagged: Boolean
}

input FeedbackUpdateManyWithoutFeedbackGiverInput {
  create: [FeedbackCreateWithoutFeedbackGiverInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutFeedbackGiverInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutFeedbackGiverInput!]
  deleteMany: [FeedbackScalarWhereInput!]
  updateMany: [FeedbackUpdateManyWithWhereNestedInput!]
}

input FeedbackUpdateManyWithoutFeedbackReceiverInput {
  create: [FeedbackCreateWithoutFeedbackReceiverInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutFeedbackReceiverInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutFeedbackReceiverInput!]
  deleteMany: [FeedbackScalarWhereInput!]
  updateMany: [FeedbackUpdateManyWithWhereNestedInput!]
}

input FeedbackUpdateManyWithoutFlaggedByInput {
  create: [FeedbackCreateWithoutFlaggedByInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutFlaggedByInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutFlaggedByInput!]
  deleteMany: [FeedbackScalarWhereInput!]
  updateMany: [FeedbackUpdateManyWithWhereNestedInput!]
}

input FeedbackUpdateManyWithWhereNestedInput {
  where: FeedbackScalarWhereInput!
  data: FeedbackUpdateManyDataInput!
}

input FeedbackUpdateWithoutFeedbackGiverDataInput {
  text: String
  flagged: Boolean
  flaggedBy: UserUpdateOneWithoutFeedbackFlaggedInput
  feedbackReceiver: UserUpdateOneRequiredWithoutFeedbackReceivedInput
}

input FeedbackUpdateWithoutFeedbackReceiverDataInput {
  text: String
  flagged: Boolean
  flaggedBy: UserUpdateOneWithoutFeedbackFlaggedInput
  feedbackGiver: UserUpdateOneRequiredWithoutFeedbackGivenInput
}

input FeedbackUpdateWithoutFlaggedByDataInput {
  text: String
  flagged: Boolean
  feedbackReceiver: UserUpdateOneRequiredWithoutFeedbackReceivedInput
  feedbackGiver: UserUpdateOneRequiredWithoutFeedbackGivenInput
}

input FeedbackUpdateWithWhereUniqueWithoutFeedbackGiverInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutFeedbackGiverDataInput!
}

input FeedbackUpdateWithWhereUniqueWithoutFeedbackReceiverInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutFeedbackReceiverDataInput!
}

input FeedbackUpdateWithWhereUniqueWithoutFlaggedByInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutFlaggedByDataInput!
}

input FeedbackUpsertWithWhereUniqueWithoutFeedbackGiverInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutFeedbackGiverDataInput!
  create: FeedbackCreateWithoutFeedbackGiverInput!
}

input FeedbackUpsertWithWhereUniqueWithoutFeedbackReceiverInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutFeedbackReceiverDataInput!
  create: FeedbackCreateWithoutFeedbackReceiverInput!
}

input FeedbackUpsertWithWhereUniqueWithoutFlaggedByInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutFlaggedByDataInput!
  create: FeedbackCreateWithoutFlaggedByInput!
}

input FeedbackWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  flagged: Boolean
  flagged_not: Boolean
  flaggedBy: UserWhereInput
  feedbackReceiver: UserWhereInput
  feedbackGiver: UserWhereInput
  AND: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  NOT: [FeedbackWhereInput!]
}

input FeedbackWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBlurb(data: BlurbCreateInput!): Blurb!
  updateBlurb(data: BlurbUpdateInput!, where: BlurbWhereUniqueInput!): Blurb
  updateManyBlurbs(data: BlurbUpdateManyMutationInput!, where: BlurbWhereInput): BatchPayload!
  upsertBlurb(where: BlurbWhereUniqueInput!, create: BlurbCreateInput!, update: BlurbUpdateInput!): Blurb!
  deleteBlurb(where: BlurbWhereUniqueInput!): Blurb
  deleteManyBlurbs(where: BlurbWhereInput): BatchPayload!
  createFeedback(data: FeedbackCreateInput!): Feedback!
  updateFeedback(data: FeedbackUpdateInput!, where: FeedbackWhereUniqueInput!): Feedback
  updateManyFeedbacks(data: FeedbackUpdateManyMutationInput!, where: FeedbackWhereInput): BatchPayload!
  upsertFeedback(where: FeedbackWhereUniqueInput!, create: FeedbackCreateInput!, update: FeedbackUpdateInput!): Feedback!
  deleteFeedback(where: FeedbackWhereUniqueInput!): Feedback
  deleteManyFeedbacks(where: FeedbackWhereInput): BatchPayload!
  createPic(data: PicCreateInput!): Pic!
  updatePic(data: PicUpdateInput!, where: PicWhereUniqueInput!): Pic
  updateManyPics(data: PicUpdateManyMutationInput!, where: PicWhereInput): BatchPayload!
  upsertPic(where: PicWhereUniqueInput!, create: PicCreateInput!, update: PicUpdateInput!): Pic!
  deletePic(where: PicWhereUniqueInput!): Pic
  deleteManyPics(where: PicWhereInput): BatchPayload!
  createRating(data: RatingCreateInput!): Rating!
  updateRating(data: RatingUpdateInput!, where: RatingWhereUniqueInput!): Rating
  updateManyRatings(data: RatingUpdateManyMutationInput!, where: RatingWhereInput): BatchPayload!
  upsertRating(where: RatingWhereUniqueInput!, create: RatingCreateInput!, update: RatingUpdateInput!): Rating!
  deleteRating(where: RatingWhereUniqueInput!): Rating
  deleteManyRatings(where: RatingWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pic {
  id: ID!
  owner: User!
  url: String!
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating!]
}

type PicConnection {
  pageInfo: PageInfo!
  edges: [PicEdge]!
  aggregate: AggregatePic!
}

input PicCreateInput {
  id: ID
  owner: UserCreateOneWithoutPicsInput!
  url: String!
  ratings: RatingCreateManyWithoutPicInput
}

input PicCreateManyWithoutOwnerInput {
  create: [PicCreateWithoutOwnerInput!]
  connect: [PicWhereUniqueInput!]
}

input PicCreateOneWithoutRatingsInput {
  create: PicCreateWithoutRatingsInput
  connect: PicWhereUniqueInput
}

input PicCreateWithoutOwnerInput {
  id: ID
  url: String!
  ratings: RatingCreateManyWithoutPicInput
}

input PicCreateWithoutRatingsInput {
  id: ID
  owner: UserCreateOneWithoutPicsInput!
  url: String!
}

type PicEdge {
  node: Pic!
  cursor: String!
}

enum PicOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type PicPreviousValues {
  id: ID!
  url: String!
}

input PicScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [PicScalarWhereInput!]
  OR: [PicScalarWhereInput!]
  NOT: [PicScalarWhereInput!]
}

type PicSubscriptionPayload {
  mutation: MutationType!
  node: Pic
  updatedFields: [String!]
  previousValues: PicPreviousValues
}

input PicSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PicWhereInput
  AND: [PicSubscriptionWhereInput!]
  OR: [PicSubscriptionWhereInput!]
  NOT: [PicSubscriptionWhereInput!]
}

input PicUpdateInput {
  owner: UserUpdateOneRequiredWithoutPicsInput
  url: String
  ratings: RatingUpdateManyWithoutPicInput
}

input PicUpdateManyDataInput {
  url: String
}

input PicUpdateManyMutationInput {
  url: String
}

input PicUpdateManyWithoutOwnerInput {
  create: [PicCreateWithoutOwnerInput!]
  delete: [PicWhereUniqueInput!]
  connect: [PicWhereUniqueInput!]
  set: [PicWhereUniqueInput!]
  disconnect: [PicWhereUniqueInput!]
  update: [PicUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PicUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [PicScalarWhereInput!]
  updateMany: [PicUpdateManyWithWhereNestedInput!]
}

input PicUpdateManyWithWhereNestedInput {
  where: PicScalarWhereInput!
  data: PicUpdateManyDataInput!
}

input PicUpdateOneWithoutRatingsInput {
  create: PicCreateWithoutRatingsInput
  update: PicUpdateWithoutRatingsDataInput
  upsert: PicUpsertWithoutRatingsInput
  delete: Boolean
  disconnect: Boolean
  connect: PicWhereUniqueInput
}

input PicUpdateWithoutOwnerDataInput {
  url: String
  ratings: RatingUpdateManyWithoutPicInput
}

input PicUpdateWithoutRatingsDataInput {
  owner: UserUpdateOneRequiredWithoutPicsInput
  url: String
}

input PicUpdateWithWhereUniqueWithoutOwnerInput {
  where: PicWhereUniqueInput!
  data: PicUpdateWithoutOwnerDataInput!
}

input PicUpsertWithoutRatingsInput {
  update: PicUpdateWithoutRatingsDataInput!
  create: PicCreateWithoutRatingsInput!
}

input PicUpsertWithWhereUniqueWithoutOwnerInput {
  where: PicWhereUniqueInput!
  update: PicUpdateWithoutOwnerDataInput!
  create: PicCreateWithoutOwnerInput!
}

input PicWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  ratings_every: RatingWhereInput
  ratings_some: RatingWhereInput
  ratings_none: RatingWhereInput
  AND: [PicWhereInput!]
  OR: [PicWhereInput!]
  NOT: [PicWhereInput!]
}

input PicWhereUniqueInput {
  id: ID
}

type Query {
  blurb(where: BlurbWhereUniqueInput!): Blurb
  blurbs(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Blurb]!
  blurbsConnection(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BlurbConnection!
  feedback(where: FeedbackWhereUniqueInput!): Feedback
  feedbacks(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback]!
  feedbacksConnection(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackConnection!
  pic(where: PicWhereUniqueInput!): Pic
  pics(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pic]!
  picsConnection(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PicConnection!
  rating(where: RatingWhereUniqueInput!): Rating
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating]!
  ratingsConnection(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RatingConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Rating {
  id: ID!
  pic: Pic
  blurb: Blurb
  score: Int!
  ratingGiverAge: Int!
  ratingGiver: User!
}

type RatingConnection {
  pageInfo: PageInfo!
  edges: [RatingEdge]!
  aggregate: AggregateRating!
}

input RatingCreateInput {
  id: ID
  pic: PicCreateOneWithoutRatingsInput
  blurb: BlurbCreateOneWithoutRatingsInput
  score: Int!
  ratingGiverAge: Int!
  ratingGiver: UserCreateOneInput!
}

input RatingCreateManyWithoutBlurbInput {
  create: [RatingCreateWithoutBlurbInput!]
  connect: [RatingWhereUniqueInput!]
}

input RatingCreateManyWithoutPicInput {
  create: [RatingCreateWithoutPicInput!]
  connect: [RatingWhereUniqueInput!]
}

input RatingCreateWithoutBlurbInput {
  id: ID
  pic: PicCreateOneWithoutRatingsInput
  score: Int!
  ratingGiverAge: Int!
  ratingGiver: UserCreateOneInput!
}

input RatingCreateWithoutPicInput {
  id: ID
  blurb: BlurbCreateOneWithoutRatingsInput
  score: Int!
  ratingGiverAge: Int!
  ratingGiver: UserCreateOneInput!
}

type RatingEdge {
  node: Rating!
  cursor: String!
}

enum RatingOrderByInput {
  id_ASC
  id_DESC
  score_ASC
  score_DESC
  ratingGiverAge_ASC
  ratingGiverAge_DESC
}

type RatingPreviousValues {
  id: ID!
  score: Int!
  ratingGiverAge: Int!
}

input RatingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  ratingGiverAge: Int
  ratingGiverAge_not: Int
  ratingGiverAge_in: [Int!]
  ratingGiverAge_not_in: [Int!]
  ratingGiverAge_lt: Int
  ratingGiverAge_lte: Int
  ratingGiverAge_gt: Int
  ratingGiverAge_gte: Int
  AND: [RatingScalarWhereInput!]
  OR: [RatingScalarWhereInput!]
  NOT: [RatingScalarWhereInput!]
}

type RatingSubscriptionPayload {
  mutation: MutationType!
  node: Rating
  updatedFields: [String!]
  previousValues: RatingPreviousValues
}

input RatingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RatingWhereInput
  AND: [RatingSubscriptionWhereInput!]
  OR: [RatingSubscriptionWhereInput!]
  NOT: [RatingSubscriptionWhereInput!]
}

input RatingUpdateInput {
  pic: PicUpdateOneWithoutRatingsInput
  blurb: BlurbUpdateOneWithoutRatingsInput
  score: Int
  ratingGiverAge: Int
  ratingGiver: UserUpdateOneRequiredInput
}

input RatingUpdateManyDataInput {
  score: Int
  ratingGiverAge: Int
}

input RatingUpdateManyMutationInput {
  score: Int
  ratingGiverAge: Int
}

input RatingUpdateManyWithoutBlurbInput {
  create: [RatingCreateWithoutBlurbInput!]
  delete: [RatingWhereUniqueInput!]
  connect: [RatingWhereUniqueInput!]
  set: [RatingWhereUniqueInput!]
  disconnect: [RatingWhereUniqueInput!]
  update: [RatingUpdateWithWhereUniqueWithoutBlurbInput!]
  upsert: [RatingUpsertWithWhereUniqueWithoutBlurbInput!]
  deleteMany: [RatingScalarWhereInput!]
  updateMany: [RatingUpdateManyWithWhereNestedInput!]
}

input RatingUpdateManyWithoutPicInput {
  create: [RatingCreateWithoutPicInput!]
  delete: [RatingWhereUniqueInput!]
  connect: [RatingWhereUniqueInput!]
  set: [RatingWhereUniqueInput!]
  disconnect: [RatingWhereUniqueInput!]
  update: [RatingUpdateWithWhereUniqueWithoutPicInput!]
  upsert: [RatingUpsertWithWhereUniqueWithoutPicInput!]
  deleteMany: [RatingScalarWhereInput!]
  updateMany: [RatingUpdateManyWithWhereNestedInput!]
}

input RatingUpdateManyWithWhereNestedInput {
  where: RatingScalarWhereInput!
  data: RatingUpdateManyDataInput!
}

input RatingUpdateWithoutBlurbDataInput {
  pic: PicUpdateOneWithoutRatingsInput
  score: Int
  ratingGiverAge: Int
  ratingGiver: UserUpdateOneRequiredInput
}

input RatingUpdateWithoutPicDataInput {
  blurb: BlurbUpdateOneWithoutRatingsInput
  score: Int
  ratingGiverAge: Int
  ratingGiver: UserUpdateOneRequiredInput
}

input RatingUpdateWithWhereUniqueWithoutBlurbInput {
  where: RatingWhereUniqueInput!
  data: RatingUpdateWithoutBlurbDataInput!
}

input RatingUpdateWithWhereUniqueWithoutPicInput {
  where: RatingWhereUniqueInput!
  data: RatingUpdateWithoutPicDataInput!
}

input RatingUpsertWithWhereUniqueWithoutBlurbInput {
  where: RatingWhereUniqueInput!
  update: RatingUpdateWithoutBlurbDataInput!
  create: RatingCreateWithoutBlurbInput!
}

input RatingUpsertWithWhereUniqueWithoutPicInput {
  where: RatingWhereUniqueInput!
  update: RatingUpdateWithoutPicDataInput!
  create: RatingCreateWithoutPicInput!
}

input RatingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pic: PicWhereInput
  blurb: BlurbWhereInput
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  ratingGiverAge: Int
  ratingGiverAge_not: Int
  ratingGiverAge_in: [Int!]
  ratingGiverAge_not_in: [Int!]
  ratingGiverAge_lt: Int
  ratingGiverAge_lte: Int
  ratingGiverAge_gt: Int
  ratingGiverAge_gte: Int
  ratingGiver: UserWhereInput
  AND: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  NOT: [RatingWhereInput!]
}

input RatingWhereUniqueInput {
  id: ID
}

type Subscription {
  blurb(where: BlurbSubscriptionWhereInput): BlurbSubscriptionPayload
  feedback(where: FeedbackSubscriptionWhereInput): FeedbackSubscriptionPayload
  pic(where: PicSubscriptionWhereInput): PicSubscriptionPayload
  rating(where: RatingSubscriptionWhereInput): RatingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  birthday: String!
  blurbs(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Blurb!]
  email: String!
  feedbackFlagged(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback!]
  feedbackGiven(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback!]
  feedbackReceived(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback!]
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID!
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pic!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  birthday: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  email: String!
  feedbackFlagged: FeedbackCreateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackCreateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackCreateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBlurbsInput {
  create: UserCreateWithoutBlurbsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFeedbackFlaggedInput {
  create: UserCreateWithoutFeedbackFlaggedInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFeedbackGivenInput {
  create: UserCreateWithoutFeedbackGivenInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFeedbackReceivedInput {
  create: UserCreateWithoutFeedbackReceivedInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPicsInput {
  create: UserCreateWithoutPicsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBlurbsInput {
  birthday: String!
  email: String!
  feedbackFlagged: FeedbackCreateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackCreateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackCreateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateWithoutFeedbackFlaggedInput {
  birthday: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  email: String!
  feedbackGiven: FeedbackCreateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackCreateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateWithoutFeedbackGivenInput {
  birthday: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  email: String!
  feedbackFlagged: FeedbackCreateManyWithoutFlaggedByInput
  feedbackReceived: FeedbackCreateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateWithoutFeedbackReceivedInput {
  birthday: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  email: String!
  feedbackFlagged: FeedbackCreateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackCreateManyWithoutFeedbackGiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateWithoutPicsInput {
  birthday: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  email: String!
  feedbackFlagged: FeedbackCreateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackCreateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackCreateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  birthday_ASC
  birthday_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  genderIdentityMale_ASC
  genderIdentityMale_DESC
  genderIdentityFemale_ASC
  genderIdentityFemale_DESC
  genderIdentityNonBi_ASC
  genderIdentityNonBi_DESC
  genderPreferenceMale_ASC
  genderPreferenceMale_DESC
  genderPreferenceFemale_ASC
  genderPreferenceFemale_DESC
  genderPreferenceNonBi_ASC
  genderPreferenceNonBi_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  maxAge_ASC
  maxAge_DESC
  minAge_ASC
  minAge_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  birthday: String!
  email: String!
  firstName: String
  genderIdentityMale: Boolean!
  genderIdentityFemale: Boolean!
  genderIdentityNonBi: Boolean!
  genderPreferenceMale: Boolean!
  genderPreferenceFemale: Boolean!
  genderPreferenceNonBi: Boolean!
  id: ID!
  lastName: String
  maxAge: Int!
  minAge: Int!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  birthday: String
  email: String
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBlurbsInput {
  create: UserCreateWithoutBlurbsInput
  update: UserUpdateWithoutBlurbsDataInput
  upsert: UserUpsertWithoutBlurbsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFeedbackGivenInput {
  create: UserCreateWithoutFeedbackGivenInput
  update: UserUpdateWithoutFeedbackGivenDataInput
  upsert: UserUpsertWithoutFeedbackGivenInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFeedbackReceivedInput {
  create: UserCreateWithoutFeedbackReceivedInput
  update: UserUpdateWithoutFeedbackReceivedDataInput
  upsert: UserUpsertWithoutFeedbackReceivedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPicsInput {
  create: UserCreateWithoutPicsInput
  update: UserUpdateWithoutPicsDataInput
  upsert: UserUpsertWithoutPicsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutFeedbackFlaggedInput {
  create: UserCreateWithoutFeedbackFlaggedInput
  update: UserUpdateWithoutFeedbackFlaggedDataInput
  upsert: UserUpsertWithoutFeedbackFlaggedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBlurbsDataInput {
  birthday: String
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutFeedbackFlaggedDataInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutFeedbackGivenDataInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutFeedbackReceivedDataInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutPicsDataInput {
  birthday: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  email: String
  feedbackFlagged: FeedbackUpdateManyWithoutFlaggedByInput
  feedbackGiven: FeedbackUpdateManyWithoutFeedbackGiverInput
  feedbackReceived: FeedbackUpdateManyWithoutFeedbackReceiverInput
  firstName: String
  genderIdentityMale: Boolean
  genderIdentityFemale: Boolean
  genderIdentityNonBi: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceNonBi: Boolean
  lastName: String
  maxAge: Int
  minAge: Int
  password: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutBlurbsInput {
  update: UserUpdateWithoutBlurbsDataInput!
  create: UserCreateWithoutBlurbsInput!
}

input UserUpsertWithoutFeedbackFlaggedInput {
  update: UserUpdateWithoutFeedbackFlaggedDataInput!
  create: UserCreateWithoutFeedbackFlaggedInput!
}

input UserUpsertWithoutFeedbackGivenInput {
  update: UserUpdateWithoutFeedbackGivenDataInput!
  create: UserCreateWithoutFeedbackGivenInput!
}

input UserUpsertWithoutFeedbackReceivedInput {
  update: UserUpdateWithoutFeedbackReceivedDataInput!
  create: UserCreateWithoutFeedbackReceivedInput!
}

input UserUpsertWithoutPicsInput {
  update: UserUpdateWithoutPicsDataInput!
  create: UserCreateWithoutPicsInput!
}

input UserWhereInput {
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  blurbs_every: BlurbWhereInput
  blurbs_some: BlurbWhereInput
  blurbs_none: BlurbWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  feedbackFlagged_every: FeedbackWhereInput
  feedbackFlagged_some: FeedbackWhereInput
  feedbackFlagged_none: FeedbackWhereInput
  feedbackGiven_every: FeedbackWhereInput
  feedbackGiven_some: FeedbackWhereInput
  feedbackGiven_none: FeedbackWhereInput
  feedbackReceived_every: FeedbackWhereInput
  feedbackReceived_some: FeedbackWhereInput
  feedbackReceived_none: FeedbackWhereInput
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  genderIdentityMale: Boolean
  genderIdentityMale_not: Boolean
  genderIdentityFemale: Boolean
  genderIdentityFemale_not: Boolean
  genderIdentityNonBi: Boolean
  genderIdentityNonBi_not: Boolean
  genderPreferenceMale: Boolean
  genderPreferenceMale_not: Boolean
  genderPreferenceFemale: Boolean
  genderPreferenceFemale_not: Boolean
  genderPreferenceNonBi: Boolean
  genderPreferenceNonBi_not: Boolean
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  maxAge: Int
  maxAge_not: Int
  maxAge_in: [Int!]
  maxAge_not_in: [Int!]
  maxAge_lt: Int
  maxAge_lte: Int
  maxAge_gt: Int
  maxAge_gte: Int
  minAge: Int
  minAge_not: Int
  minAge_in: [Int!]
  minAge_not_in: [Int!]
  minAge_lt: Int
  minAge_lte: Int
  minAge_gt: Int
  minAge_gte: Int
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  pics_every: PicWhereInput
  pics_some: PicWhereInput
  pics_none: PicWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
`
      }
    