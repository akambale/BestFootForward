module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBlurb {
  count: Int!
}

type AggregateFeedback {
  count: Int!
}

type AggregatePic {
  count: Int!
}

type AggregateRating {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Blurb {
  id: ID!
  owner: User!
  text: String!
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating!]
}

type BlurbConnection {
  pageInfo: PageInfo!
  edges: [BlurbEdge]!
  aggregate: AggregateBlurb!
}

input BlurbCreateInput {
  id: ID
  owner: UserCreateOneWithoutBlurbsInput!
  text: String!
  ratings: RatingCreateManyWithoutBlurbInput
}

input BlurbCreateManyWithoutOwnerInput {
  create: [BlurbCreateWithoutOwnerInput!]
  connect: [BlurbWhereUniqueInput!]
}

input BlurbCreateOneWithoutRatingsInput {
  create: BlurbCreateWithoutRatingsInput
  connect: BlurbWhereUniqueInput
}

input BlurbCreateWithoutOwnerInput {
  id: ID
  text: String!
  ratings: RatingCreateManyWithoutBlurbInput
}

input BlurbCreateWithoutRatingsInput {
  id: ID
  owner: UserCreateOneWithoutBlurbsInput!
  text: String!
}

type BlurbEdge {
  node: Blurb!
  cursor: String!
}

enum BlurbOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type BlurbPreviousValues {
  id: ID!
  text: String!
}

input BlurbScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [BlurbScalarWhereInput!]
  OR: [BlurbScalarWhereInput!]
  NOT: [BlurbScalarWhereInput!]
}

type BlurbSubscriptionPayload {
  mutation: MutationType!
  node: Blurb
  updatedFields: [String!]
  previousValues: BlurbPreviousValues
}

input BlurbSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BlurbWhereInput
  AND: [BlurbSubscriptionWhereInput!]
  OR: [BlurbSubscriptionWhereInput!]
  NOT: [BlurbSubscriptionWhereInput!]
}

input BlurbUpdateInput {
  owner: UserUpdateOneRequiredWithoutBlurbsInput
  text: String
  ratings: RatingUpdateManyWithoutBlurbInput
}

input BlurbUpdateManyDataInput {
  text: String
}

input BlurbUpdateManyMutationInput {
  text: String
}

input BlurbUpdateManyWithoutOwnerInput {
  create: [BlurbCreateWithoutOwnerInput!]
  delete: [BlurbWhereUniqueInput!]
  connect: [BlurbWhereUniqueInput!]
  set: [BlurbWhereUniqueInput!]
  disconnect: [BlurbWhereUniqueInput!]
  update: [BlurbUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [BlurbUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [BlurbScalarWhereInput!]
  updateMany: [BlurbUpdateManyWithWhereNestedInput!]
}

input BlurbUpdateManyWithWhereNestedInput {
  where: BlurbScalarWhereInput!
  data: BlurbUpdateManyDataInput!
}

input BlurbUpdateOneWithoutRatingsInput {
  create: BlurbCreateWithoutRatingsInput
  update: BlurbUpdateWithoutRatingsDataInput
  upsert: BlurbUpsertWithoutRatingsInput
  delete: Boolean
  disconnect: Boolean
  connect: BlurbWhereUniqueInput
}

input BlurbUpdateWithoutOwnerDataInput {
  text: String
  ratings: RatingUpdateManyWithoutBlurbInput
}

input BlurbUpdateWithoutRatingsDataInput {
  owner: UserUpdateOneRequiredWithoutBlurbsInput
  text: String
}

input BlurbUpdateWithWhereUniqueWithoutOwnerInput {
  where: BlurbWhereUniqueInput!
  data: BlurbUpdateWithoutOwnerDataInput!
}

input BlurbUpsertWithoutRatingsInput {
  update: BlurbUpdateWithoutRatingsDataInput!
  create: BlurbCreateWithoutRatingsInput!
}

input BlurbUpsertWithWhereUniqueWithoutOwnerInput {
  where: BlurbWhereUniqueInput!
  update: BlurbUpdateWithoutOwnerDataInput!
  create: BlurbCreateWithoutOwnerInput!
}

input BlurbWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  ratings_every: RatingWhereInput
  ratings_some: RatingWhereInput
  ratings_none: RatingWhereInput
  AND: [BlurbWhereInput!]
  OR: [BlurbWhereInput!]
  NOT: [BlurbWhereInput!]
}

input BlurbWhereUniqueInput {
  id: ID
}

scalar DateTime

type Feedback {
  id: ID!
  contentOwner: User!
  feedbackGiver: String!
  text: String!
  createdAt: DateTime!
}

type FeedbackConnection {
  pageInfo: PageInfo!
  edges: [FeedbackEdge]!
  aggregate: AggregateFeedback!
}

input FeedbackCreateInput {
  id: ID
  contentOwner: UserCreateOneWithoutFeedbackInput!
  feedbackGiver: String!
  text: String!
}

input FeedbackCreateManyWithoutContentOwnerInput {
  create: [FeedbackCreateWithoutContentOwnerInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateWithoutContentOwnerInput {
  id: ID
  feedbackGiver: String!
  text: String!
}

type FeedbackEdge {
  node: Feedback!
  cursor: String!
}

enum FeedbackOrderByInput {
  id_ASC
  id_DESC
  feedbackGiver_ASC
  feedbackGiver_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
}

type FeedbackPreviousValues {
  id: ID!
  feedbackGiver: String!
  text: String!
  createdAt: DateTime!
}

input FeedbackScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  feedbackGiver: String
  feedbackGiver_not: String
  feedbackGiver_in: [String!]
  feedbackGiver_not_in: [String!]
  feedbackGiver_lt: String
  feedbackGiver_lte: String
  feedbackGiver_gt: String
  feedbackGiver_gte: String
  feedbackGiver_contains: String
  feedbackGiver_not_contains: String
  feedbackGiver_starts_with: String
  feedbackGiver_not_starts_with: String
  feedbackGiver_ends_with: String
  feedbackGiver_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FeedbackScalarWhereInput!]
  OR: [FeedbackScalarWhereInput!]
  NOT: [FeedbackScalarWhereInput!]
}

type FeedbackSubscriptionPayload {
  mutation: MutationType!
  node: Feedback
  updatedFields: [String!]
  previousValues: FeedbackPreviousValues
}

input FeedbackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackWhereInput
  AND: [FeedbackSubscriptionWhereInput!]
  OR: [FeedbackSubscriptionWhereInput!]
  NOT: [FeedbackSubscriptionWhereInput!]
}

input FeedbackUpdateInput {
  contentOwner: UserUpdateOneRequiredWithoutFeedbackInput
  feedbackGiver: String
  text: String
}

input FeedbackUpdateManyDataInput {
  feedbackGiver: String
  text: String
}

input FeedbackUpdateManyMutationInput {
  feedbackGiver: String
  text: String
}

input FeedbackUpdateManyWithoutContentOwnerInput {
  create: [FeedbackCreateWithoutContentOwnerInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutContentOwnerInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutContentOwnerInput!]
  deleteMany: [FeedbackScalarWhereInput!]
  updateMany: [FeedbackUpdateManyWithWhereNestedInput!]
}

input FeedbackUpdateManyWithWhereNestedInput {
  where: FeedbackScalarWhereInput!
  data: FeedbackUpdateManyDataInput!
}

input FeedbackUpdateWithoutContentOwnerDataInput {
  feedbackGiver: String
  text: String
}

input FeedbackUpdateWithWhereUniqueWithoutContentOwnerInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutContentOwnerDataInput!
}

input FeedbackUpsertWithWhereUniqueWithoutContentOwnerInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutContentOwnerDataInput!
  create: FeedbackCreateWithoutContentOwnerInput!
}

input FeedbackWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  contentOwner: UserWhereInput
  feedbackGiver: String
  feedbackGiver_not: String
  feedbackGiver_in: [String!]
  feedbackGiver_not_in: [String!]
  feedbackGiver_lt: String
  feedbackGiver_lte: String
  feedbackGiver_gt: String
  feedbackGiver_gte: String
  feedbackGiver_contains: String
  feedbackGiver_not_contains: String
  feedbackGiver_starts_with: String
  feedbackGiver_not_starts_with: String
  feedbackGiver_ends_with: String
  feedbackGiver_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  NOT: [FeedbackWhereInput!]
}

input FeedbackWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBlurb(data: BlurbCreateInput!): Blurb!
  updateBlurb(data: BlurbUpdateInput!, where: BlurbWhereUniqueInput!): Blurb
  updateManyBlurbs(data: BlurbUpdateManyMutationInput!, where: BlurbWhereInput): BatchPayload!
  upsertBlurb(where: BlurbWhereUniqueInput!, create: BlurbCreateInput!, update: BlurbUpdateInput!): Blurb!
  deleteBlurb(where: BlurbWhereUniqueInput!): Blurb
  deleteManyBlurbs(where: BlurbWhereInput): BatchPayload!
  createFeedback(data: FeedbackCreateInput!): Feedback!
  updateFeedback(data: FeedbackUpdateInput!, where: FeedbackWhereUniqueInput!): Feedback
  updateManyFeedbacks(data: FeedbackUpdateManyMutationInput!, where: FeedbackWhereInput): BatchPayload!
  upsertFeedback(where: FeedbackWhereUniqueInput!, create: FeedbackCreateInput!, update: FeedbackUpdateInput!): Feedback!
  deleteFeedback(where: FeedbackWhereUniqueInput!): Feedback
  deleteManyFeedbacks(where: FeedbackWhereInput): BatchPayload!
  createPic(data: PicCreateInput!): Pic!
  updatePic(data: PicUpdateInput!, where: PicWhereUniqueInput!): Pic
  updateManyPics(data: PicUpdateManyMutationInput!, where: PicWhereInput): BatchPayload!
  upsertPic(where: PicWhereUniqueInput!, create: PicCreateInput!, update: PicUpdateInput!): Pic!
  deletePic(where: PicWhereUniqueInput!): Pic
  deleteManyPics(where: PicWhereInput): BatchPayload!
  createRating(data: RatingCreateInput!): Rating!
  updateRating(data: RatingUpdateInput!, where: RatingWhereUniqueInput!): Rating
  updateManyRatings(data: RatingUpdateManyMutationInput!, where: RatingWhereInput): BatchPayload!
  upsertRating(where: RatingWhereUniqueInput!, create: RatingCreateInput!, update: RatingUpdateInput!): Rating!
  deleteRating(where: RatingWhereUniqueInput!): Rating
  deleteManyRatings(where: RatingWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pic {
  id: ID!
  owner: User!
  url: String!
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating!]
}

type PicConnection {
  pageInfo: PageInfo!
  edges: [PicEdge]!
  aggregate: AggregatePic!
}

input PicCreateInput {
  id: ID
  owner: UserCreateOneWithoutPicsInput!
  url: String!
  ratings: RatingCreateManyWithoutPicInput
}

input PicCreateManyWithoutOwnerInput {
  create: [PicCreateWithoutOwnerInput!]
  connect: [PicWhereUniqueInput!]
}

input PicCreateOneWithoutRatingsInput {
  create: PicCreateWithoutRatingsInput
  connect: PicWhereUniqueInput
}

input PicCreateWithoutOwnerInput {
  id: ID
  url: String!
  ratings: RatingCreateManyWithoutPicInput
}

input PicCreateWithoutRatingsInput {
  id: ID
  owner: UserCreateOneWithoutPicsInput!
  url: String!
}

type PicEdge {
  node: Pic!
  cursor: String!
}

enum PicOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type PicPreviousValues {
  id: ID!
  url: String!
}

input PicScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [PicScalarWhereInput!]
  OR: [PicScalarWhereInput!]
  NOT: [PicScalarWhereInput!]
}

type PicSubscriptionPayload {
  mutation: MutationType!
  node: Pic
  updatedFields: [String!]
  previousValues: PicPreviousValues
}

input PicSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PicWhereInput
  AND: [PicSubscriptionWhereInput!]
  OR: [PicSubscriptionWhereInput!]
  NOT: [PicSubscriptionWhereInput!]
}

input PicUpdateInput {
  owner: UserUpdateOneRequiredWithoutPicsInput
  url: String
  ratings: RatingUpdateManyWithoutPicInput
}

input PicUpdateManyDataInput {
  url: String
}

input PicUpdateManyMutationInput {
  url: String
}

input PicUpdateManyWithoutOwnerInput {
  create: [PicCreateWithoutOwnerInput!]
  delete: [PicWhereUniqueInput!]
  connect: [PicWhereUniqueInput!]
  set: [PicWhereUniqueInput!]
  disconnect: [PicWhereUniqueInput!]
  update: [PicUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PicUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [PicScalarWhereInput!]
  updateMany: [PicUpdateManyWithWhereNestedInput!]
}

input PicUpdateManyWithWhereNestedInput {
  where: PicScalarWhereInput!
  data: PicUpdateManyDataInput!
}

input PicUpdateOneWithoutRatingsInput {
  create: PicCreateWithoutRatingsInput
  update: PicUpdateWithoutRatingsDataInput
  upsert: PicUpsertWithoutRatingsInput
  delete: Boolean
  disconnect: Boolean
  connect: PicWhereUniqueInput
}

input PicUpdateWithoutOwnerDataInput {
  url: String
  ratings: RatingUpdateManyWithoutPicInput
}

input PicUpdateWithoutRatingsDataInput {
  owner: UserUpdateOneRequiredWithoutPicsInput
  url: String
}

input PicUpdateWithWhereUniqueWithoutOwnerInput {
  where: PicWhereUniqueInput!
  data: PicUpdateWithoutOwnerDataInput!
}

input PicUpsertWithoutRatingsInput {
  update: PicUpdateWithoutRatingsDataInput!
  create: PicCreateWithoutRatingsInput!
}

input PicUpsertWithWhereUniqueWithoutOwnerInput {
  where: PicWhereUniqueInput!
  update: PicUpdateWithoutOwnerDataInput!
  create: PicCreateWithoutOwnerInput!
}

input PicWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  ratings_every: RatingWhereInput
  ratings_some: RatingWhereInput
  ratings_none: RatingWhereInput
  AND: [PicWhereInput!]
  OR: [PicWhereInput!]
  NOT: [PicWhereInput!]
}

input PicWhereUniqueInput {
  id: ID
}

type Query {
  blurb(where: BlurbWhereUniqueInput!): Blurb
  blurbs(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Blurb]!
  blurbsConnection(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BlurbConnection!
  feedback(where: FeedbackWhereUniqueInput!): Feedback
  feedbacks(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback]!
  feedbacksConnection(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackConnection!
  pic(where: PicWhereUniqueInput!): Pic
  pics(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pic]!
  picsConnection(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PicConnection!
  rating(where: RatingWhereUniqueInput!): Rating
  ratings(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rating]!
  ratingsConnection(where: RatingWhereInput, orderBy: RatingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RatingConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Rating {
  id: ID!
  pic: Pic
  blurb: Blurb
  score: Int!
}

type RatingConnection {
  pageInfo: PageInfo!
  edges: [RatingEdge]!
  aggregate: AggregateRating!
}

input RatingCreateInput {
  id: ID
  pic: PicCreateOneWithoutRatingsInput
  blurb: BlurbCreateOneWithoutRatingsInput
  score: Int!
}

input RatingCreateManyWithoutBlurbInput {
  create: [RatingCreateWithoutBlurbInput!]
  connect: [RatingWhereUniqueInput!]
}

input RatingCreateManyWithoutPicInput {
  create: [RatingCreateWithoutPicInput!]
  connect: [RatingWhereUniqueInput!]
}

input RatingCreateWithoutBlurbInput {
  id: ID
  pic: PicCreateOneWithoutRatingsInput
  score: Int!
}

input RatingCreateWithoutPicInput {
  id: ID
  blurb: BlurbCreateOneWithoutRatingsInput
  score: Int!
}

type RatingEdge {
  node: Rating!
  cursor: String!
}

enum RatingOrderByInput {
  id_ASC
  id_DESC
  score_ASC
  score_DESC
}

type RatingPreviousValues {
  id: ID!
  score: Int!
}

input RatingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [RatingScalarWhereInput!]
  OR: [RatingScalarWhereInput!]
  NOT: [RatingScalarWhereInput!]
}

type RatingSubscriptionPayload {
  mutation: MutationType!
  node: Rating
  updatedFields: [String!]
  previousValues: RatingPreviousValues
}

input RatingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RatingWhereInput
  AND: [RatingSubscriptionWhereInput!]
  OR: [RatingSubscriptionWhereInput!]
  NOT: [RatingSubscriptionWhereInput!]
}

input RatingUpdateInput {
  pic: PicUpdateOneWithoutRatingsInput
  blurb: BlurbUpdateOneWithoutRatingsInput
  score: Int
}

input RatingUpdateManyDataInput {
  score: Int
}

input RatingUpdateManyMutationInput {
  score: Int
}

input RatingUpdateManyWithoutBlurbInput {
  create: [RatingCreateWithoutBlurbInput!]
  delete: [RatingWhereUniqueInput!]
  connect: [RatingWhereUniqueInput!]
  set: [RatingWhereUniqueInput!]
  disconnect: [RatingWhereUniqueInput!]
  update: [RatingUpdateWithWhereUniqueWithoutBlurbInput!]
  upsert: [RatingUpsertWithWhereUniqueWithoutBlurbInput!]
  deleteMany: [RatingScalarWhereInput!]
  updateMany: [RatingUpdateManyWithWhereNestedInput!]
}

input RatingUpdateManyWithoutPicInput {
  create: [RatingCreateWithoutPicInput!]
  delete: [RatingWhereUniqueInput!]
  connect: [RatingWhereUniqueInput!]
  set: [RatingWhereUniqueInput!]
  disconnect: [RatingWhereUniqueInput!]
  update: [RatingUpdateWithWhereUniqueWithoutPicInput!]
  upsert: [RatingUpsertWithWhereUniqueWithoutPicInput!]
  deleteMany: [RatingScalarWhereInput!]
  updateMany: [RatingUpdateManyWithWhereNestedInput!]
}

input RatingUpdateManyWithWhereNestedInput {
  where: RatingScalarWhereInput!
  data: RatingUpdateManyDataInput!
}

input RatingUpdateWithoutBlurbDataInput {
  pic: PicUpdateOneWithoutRatingsInput
  score: Int
}

input RatingUpdateWithoutPicDataInput {
  blurb: BlurbUpdateOneWithoutRatingsInput
  score: Int
}

input RatingUpdateWithWhereUniqueWithoutBlurbInput {
  where: RatingWhereUniqueInput!
  data: RatingUpdateWithoutBlurbDataInput!
}

input RatingUpdateWithWhereUniqueWithoutPicInput {
  where: RatingWhereUniqueInput!
  data: RatingUpdateWithoutPicDataInput!
}

input RatingUpsertWithWhereUniqueWithoutBlurbInput {
  where: RatingWhereUniqueInput!
  update: RatingUpdateWithoutBlurbDataInput!
  create: RatingCreateWithoutBlurbInput!
}

input RatingUpsertWithWhereUniqueWithoutPicInput {
  where: RatingWhereUniqueInput!
  update: RatingUpdateWithoutPicDataInput!
  create: RatingCreateWithoutPicInput!
}

input RatingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pic: PicWhereInput
  blurb: BlurbWhereInput
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  NOT: [RatingWhereInput!]
}

input RatingWhereUniqueInput {
  id: ID
}

type Subscription {
  blurb(where: BlurbSubscriptionWhereInput): BlurbSubscriptionPayload
  feedback(where: FeedbackSubscriptionWhereInput): FeedbackSubscriptionPayload
  pic(where: PicSubscriptionWhereInput): PicSubscriptionPayload
  rating(where: RatingSubscriptionWhereInput): RatingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  birthMonth: String!
  email: String!
  password: String!
  blurbs(where: BlurbWhereInput, orderBy: BlurbOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Blurb!]
  pics(where: PicWhereInput, orderBy: PicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pic!]
  feedback(where: FeedbackWhereInput, orderBy: FeedbackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feedback!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  birthMonth: String!
  email: String!
  password: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  pics: PicCreateManyWithoutOwnerInput
  feedback: FeedbackCreateManyWithoutContentOwnerInput
}

input UserCreateOneWithoutBlurbsInput {
  create: UserCreateWithoutBlurbsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFeedbackInput {
  create: UserCreateWithoutFeedbackInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPicsInput {
  create: UserCreateWithoutPicsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBlurbsInput {
  id: ID
  name: String!
  birthMonth: String!
  email: String!
  password: String!
  pics: PicCreateManyWithoutOwnerInput
  feedback: FeedbackCreateManyWithoutContentOwnerInput
}

input UserCreateWithoutFeedbackInput {
  id: ID
  name: String!
  birthMonth: String!
  email: String!
  password: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  pics: PicCreateManyWithoutOwnerInput
}

input UserCreateWithoutPicsInput {
  id: ID
  name: String!
  birthMonth: String!
  email: String!
  password: String!
  blurbs: BlurbCreateManyWithoutOwnerInput
  feedback: FeedbackCreateManyWithoutContentOwnerInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  birthMonth_ASC
  birthMonth_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  birthMonth: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  birthMonth: String
  email: String
  password: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  pics: PicUpdateManyWithoutOwnerInput
  feedback: FeedbackUpdateManyWithoutContentOwnerInput
}

input UserUpdateManyMutationInput {
  name: String
  birthMonth: String
  email: String
  password: String
}

input UserUpdateOneRequiredWithoutBlurbsInput {
  create: UserCreateWithoutBlurbsInput
  update: UserUpdateWithoutBlurbsDataInput
  upsert: UserUpsertWithoutBlurbsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFeedbackInput {
  create: UserCreateWithoutFeedbackInput
  update: UserUpdateWithoutFeedbackDataInput
  upsert: UserUpsertWithoutFeedbackInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPicsInput {
  create: UserCreateWithoutPicsInput
  update: UserUpdateWithoutPicsDataInput
  upsert: UserUpsertWithoutPicsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBlurbsDataInput {
  name: String
  birthMonth: String
  email: String
  password: String
  pics: PicUpdateManyWithoutOwnerInput
  feedback: FeedbackUpdateManyWithoutContentOwnerInput
}

input UserUpdateWithoutFeedbackDataInput {
  name: String
  birthMonth: String
  email: String
  password: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  pics: PicUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutPicsDataInput {
  name: String
  birthMonth: String
  email: String
  password: String
  blurbs: BlurbUpdateManyWithoutOwnerInput
  feedback: FeedbackUpdateManyWithoutContentOwnerInput
}

input UserUpsertWithoutBlurbsInput {
  update: UserUpdateWithoutBlurbsDataInput!
  create: UserCreateWithoutBlurbsInput!
}

input UserUpsertWithoutFeedbackInput {
  update: UserUpdateWithoutFeedbackDataInput!
  create: UserCreateWithoutFeedbackInput!
}

input UserUpsertWithoutPicsInput {
  update: UserUpdateWithoutPicsDataInput!
  create: UserCreateWithoutPicsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  birthMonth: String
  birthMonth_not: String
  birthMonth_in: [String!]
  birthMonth_not_in: [String!]
  birthMonth_lt: String
  birthMonth_lte: String
  birthMonth_gt: String
  birthMonth_gte: String
  birthMonth_contains: String
  birthMonth_not_contains: String
  birthMonth_starts_with: String
  birthMonth_not_starts_with: String
  birthMonth_ends_with: String
  birthMonth_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  blurbs_every: BlurbWhereInput
  blurbs_some: BlurbWhereInput
  blurbs_none: BlurbWhereInput
  pics_every: PicWhereInput
  pics_some: PicWhereInput
  pics_none: PicWhereInput
  feedback_every: FeedbackWhereInput
  feedback_some: FeedbackWhereInput
  feedback_none: FeedbackWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    